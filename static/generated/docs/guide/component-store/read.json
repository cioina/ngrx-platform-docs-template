{
  "id": "guide/component-store/read",
  "title": "Reading state",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/component-store/read.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"reading-state\">Reading state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-store/read#reading-state\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"select-method\"><code>select</code> method<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-store/read#select-method\"><i class=\"material-icons\">link</i></a></h2>\n<p>Reading state is done with the <code>select</code> method, which takes a projector that describes HOW the state is retrieved and/or transformed.\nSelectors emit new values when those values \"change\" - the new value is no longer distinct by comparison from the previous value.</p>\n<p>Another performance benefit of selectors is that they are \"shared\" - they multicast the value to each subscriber.</p>\n<code-example header=\"movies.store.ts\">\nexport interface MoviesState {\n  movies: Movie[];\n}\n\n@Injectable()\nexport class MoviesStore extends ComponentStore&#x3C;MoviesState> {\n  \n  constructor() {\n    super({movies:[]});\n  }\n\n  readonly movies$:&#x3C;Movie[]> Observable = this.select(state => state.movies);\n}\n</code-example>\n<code-example header=\"movies-page.component.ts\">\n@Component({\n  template: `\n    &#x3C;li *ngFor=\"let movie of (movies$ | async)\">\n      {{ movie.name }}\n    &#x3C;/li>\n  `,\n  providers: [MoviesStore],\n})\nexport class MoviesPageComponent {\n  movies$ = this.moviesStore.movies$;\n\n  constructor(private readonly moviesStore: MoviesStore) {}\n}\n</code-example>\n<h2 id=\"combining-selectors\">Combining selectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-store/read#combining-selectors\"><i class=\"material-icons\">link</i></a></h2>\n<p>Selectors can be used to combine other Selectors or Observables.</p>\n<code-example header=\"movies.store.ts\">\nexport interface MoviesState {\n  movies: Movie[];\n  userPreferredMoviesIds: string[];\n}\n\n@Injectable()\nexport class MoviesStore extends ComponentStore&#x3C;MoviesState> {\n  \n  constructor() {\n    super({movies:[], userPreferredMoviesIds:[]});\n  }\n\n  readonly movies$ = this.select(state => state.movies);\n  readonly userPreferredMovieIds$ = this.select(state => state.userPreferredMoviesIds);\n\n  readonly userPreferredMovies$ = this.select(\n    movies$,\n    userPreferredMovieIds$,\n    (movies, ids) => movies.filter(id => ids.includes(id)),\n  );\n}\n</code-example>\n<h2 id=\"debounce-selectors\">Debounce selectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-store/read#debounce-selectors\"><i class=\"material-icons\">link</i></a></h2>\n<p>Selectors are synchronous by default, meaning that they emit the value immediately when subscribed to, and on every state change.\nSometimes the preferred behavior would be to wait (or debounce) until the state \"settles\" (meaning all the changes within the current microtask occur)\nand only then emit the final value.\nIn many cases, this would be the most performant way to read data from the ComponentStore, however its behavior might be surprising sometimes, as it won't emit a value until later on.\nThis makes it harder to test such selectors.</p>\n<p>Adding the debounce to a selector is done by passing <code>{debounce: true}</code> as the last argument.</p>\n<code-example header=\"movies.store.ts\">\n@Injectable()\nexport class MoviesStore extends ComponentStore&#x3C;MoviesState> {\n  \n  constructor() {\n    super({movies: Movie[], moviesPerPage: 10, currentPageIndex: 0});\n\n    this.effect((moviePageData$: Observable&#x3C;{moviesPerPage: number, currentPageIndex: number}>) => {\n      return moviePageData$.pipe(\n        concatMap(({moviesPerPage, currentPageIndex}) => \n            this.movieService.loadMovies(moviesPerPage, currentPageIndex)).pipe(\n              tap(results => this.updateMovieResults(results)),\n            ),\n      );\n    })(fetchMoviesData$) // ðŸ‘ˆ effect is triggered whenever debounced data is changed\n  }\n\n  // Updates how many movies per page should be displayed\n  readonly updateMoviesPerPage = this.updater((state, moviesPerPage: number) => ({\n    ...state,\n    moviesPerPage, // updates with new value\n  }));\n\n  // Updates which page of movies that the user is currently on\n  readonly updateMoviesPerPage = this.updater((state, currentPageIndex: number) => ({\n    ...state,\n    currentPageIndex, // updates with new page index\n  }));\n\n  readonly moviesPerPage$ = this.select(state => state.moviesPerPage);\n\n  readonly currentPageIndex$ = this.select(state => state.currentPageIndex);\n\n  private readonly fetchMoviesData$ = this.select(\n    moviesPerPage$,\n    currentPageIndex$,\n    (moviesPerPage, currentPageIndex) => ({moviesPerPage, currentPageIndex}),\n    {debounce: true}, // ðŸ‘ˆ setting this selector to debounce\n    );\n}\n</code-example>\n<h2 id=\"selecting-from-global-ngrxstore\">Selecting from global <code>@ngrx/store</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-store/read#selecting-from-global-ngrxstore\"><i class=\"material-icons\">link</i></a></h2>\n<p>ComponentStore is an independent library, however it can easily consume data from <code>@ngrx/store</code> or from any other global state management library.</p>\n<code-example header=\"movies.store.ts\">\n\n  private readonly fetchMoviesData$ = this.select(\n    this.store.select(getUserId), // ðŸ‘ˆ store.select returns an Observable, which is easily mixed within selector\n    moviesPerPage$,\n    currentPageIndex$,\n    (userId, moviesPerPage, currentPageIndex) => ({userId, moviesPerPage, currentPageIndex}),\n    );\n}\n</code-example>\n<h2 id=\"get-method\"><code>get</code> method<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-store/read#get-method\"><i class=\"material-icons\">link</i></a></h2>\n<p>While a selector provides a reactive way to read the state from ComponentStore via Observable, sometimes an imperative read is needed.\nOne of such use cases is accessing the state within an <code>effect</code>s and that's where <code>get</code> method could be used.</p>\n<div class=\"alert is-critical\">\n<p>The <code>get</code> method is ComponentStore-private, meaning it's accessible only within the ComponentStore. It's done to discourage frequent imperative reads\nfrom the state as the NgRx team is in a consensus that such reads promote further potentially harmful architectural decisions.</p>\n</div>\n\n</div>\n\n<!-- links to this doc:\n - guide/component-store\n-->\n<!-- links from this doc:\n - guide/component-store/read#combining-selectors\n - guide/component-store/read#debounce-selectors\n - guide/component-store/read#get-method\n - guide/component-store/read#reading-state\n - guide/component-store/read#select-method\n - guide/component-store/read#selecting-from-global-ngrxstore\n - https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/component-store/read.md?message=docs%3A%20describe%20your%20change...\n-->"
}