{
  "id": "guide/effects/testing",
  "title": "Testing",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com//edit/master/NODEJS/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#testing\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"test-helpers\">Test helpers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#test-helpers\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"providemockactions\"><code>provideMockActions</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#providemockactions\"><i class=\"material-icons\">link</i></a></h3>\n<p>An Effect subscribes to the <code>Actions</code> Observable to perform side effects.\n<code>provideMockActions</code> provides a mock provider of the <code>Actions</code> Observable to subscribe to, for each test individually.</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { provideMockActions } from '@ngrx/effects/testing';\n\nlet actions$: Observable&#x3C;Action>;\n\nTestBed.configureTestingModule({\n  providers: [provideMockActions(() => actions$)],\n});\n</code-example>\n<p>Later in the test cases, we assign the <code>actions$</code> variable to a stream of actions.</p>\n<code-example header=\"my.effects.spec.ts\">\n// by creating an Observable\nactions$ = of({ type: 'ACTION ONE' });\n\n// or by using a marble diagram\nactions$ = hot('--a-', { a: { type: 'ACTION ONE' } });\n</code-example>\n<h3 id=\"effects-with-parameters\">Effects with parameters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effects-with-parameters\"><i class=\"material-icons\">link</i></a></h3>\n<p>Creating an Effect as a function gives the opportunity to override defaults while testing the Effect.\nA common use case is to use the RxJS <code>TestScheduler</code>, or to override a default time.</p>\n<code-example header=\"my.effects.ts\">\nsearch$ = createEffect(() => ({\n  debounce = 300,\n  scheduler = asyncScheduler\n} = {}) =>\n  this.actions$.pipe(\n    ofType(BookActions.search),\n    debounceTime(debounce, scheduler),\n    ...\n  )\n);\n</code-example>\n<code-example header=\"my.effects.spec.ts\">\neffects.search$({\n  debounce: 30,\n  scheduler: getTestScheduler(),\n});\n</code-example>\n<h2 id=\"testing-practices\">Testing practices<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#testing-practices\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"marble-diagrams\">Marble diagrams<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#marble-diagrams\"><i class=\"material-icons\">link</i></a></h3>\n<p>Testing Effects via marble diagrams is particularly useful when the Effect is time sensitive or when the Effect has a lot of behavior.</p>\n<div class=\"alert is-helpful\">\n<p>For a detailed look on the marble syntax, see <a href=\"https://rxjs.dev/guide/testing/marble-testing\">Writing marble tests</a>.</p>\n<p>The <code>hot</code>, <code>cold</code>, and <code>toBeObservable</code> functions are imported from <a href=\"https://www.npmjs.com/package/jasmine-marbles\"><code>jasmine-marbles</code></a>.</p>\n</div>\n<code-example header=\"my.effects.spec.ts\">\n// create an actions stream to represent a user that is typing\nactions$ = hot('-a-b-', {\n  a: { type: 'SEARCH CUSTOMERS', name: 'J' },\n  b: { type: 'SEARCH CUSTOMERS', name: 'Jes' },\n})\n\n// mock the service to prevent an HTTP request to return an array of customers\ncustomersServiceSpy.searchCustomers.and.returnValue(\n  cold('--a|', { a: [...] })\n);\n\n// expect the first action to debounce and not to dispatch\n// expect the second action to result in a SUCCESS action\nconst expected = hot('-------a', {\n  a: {\n    type: 'SEARCH CUSTOMERS SUCCESS',\n    customers: [...],\n  },\n});\n\nexpect(\n  effects.searchCustomers$({\n    debounce: 20,\n    scheduler: getTestScheduler(),\n  })\n).toBeObservable(expected);\n</code-example>\n<h3 id=\"with-observables\">With Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#with-observables\"><i class=\"material-icons\">link</i></a></h3>\n<p>To test simple Effects, it might be easier to create an Observable instead of using a marble diagram.</p>\n<code-example header=\"my.effects.spec.ts\">\n// create an actions stream and immediately dispatch a GET action\nactions$ = of({ type: 'GET CUSTOMERS' });\n\n// mock the service to prevent an HTTP request\ncustomersServiceSpy.getAllCustomers.and.returnValue(of([...]));\n\n// subscribe to the Effect stream and verify it dispatches a SUCCESS action\neffects.getAll$.subscribe(action => {\n  expect(action).toEqual({\n    type: 'GET CUSTOMERS SUCCESS',\n    customers: [...],\n  });\n});\n</code-example>\n<h3 id=\"with-replaysubject\">With <code>ReplaySubject</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#with-replaysubject\"><i class=\"material-icons\">link</i></a></h3>\n<p>As an alternative, it's also possible to use <code>ReplaySubject</code>.</p>\n<code-example header=\"my.effects.spec.ts\">\n// create a ReplaySubject\nactions$ = new ReplaySubject(1);\n\n// mock the service to prevent an HTTP request\ncustomersServiceSpy.getAllCustomers.and.returnValue(of([...]));\n\n// dispatch the GET action\n(actions$ as ReplaySubject).next( type: 'GET CUSTOMERS' })\n\n// subscribe to the Effect stream and verify it dispatches a SUCCESS action\neffects.getAll$.subscribe(action => {\n  expect(action).toEqual({\n    type: 'GET CUSTOMERS SUCCESS',\n    customers: [...],\n  });\n});\n</code-example>\n<h2 id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#examples\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"a-non-dispatching-effect\">A non-dispatching Effect<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#a-non-dispatching-effect\"><i class=\"material-icons\">link</i></a></h3>\n<p>Until now, we only saw Effects that dispatch an Action and we verified the dispatched action.\nWith an Effect that does not dispatch an action, we can't verify the Effects stream.\nWhat we can do, is verify the side-effect has been called.</p>\n<p>An example of this is to verify we navigate to the correct page.</p>\n<code-example header=\"my.effects.spec.ts\">\nit('should navigate to the customers detail page', () => {\n  actions$ = of({ type: 'SELECT CUSTOMER', name: 'Bob' });\n  \n  // create a spy to verify the navigation will be called\n  spyOn(router, 'navigateByUrl');\n\n  // subscribe to execute the Effect\n  effects.selectCustomer$.subscribe();\n\n  // verify the navigation has been called\n  expect(router.navigateByUrl).toHaveBeenCalledWith('customers/bob');\n});\n</code-example>\n<h3 id=\"effect-that-uses-state\">Effect that uses state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effect-that-uses-state\"><i class=\"material-icons\">link</i></a></h3>\n<p>Leverage <a href=\"/guide/store/testing#using-a-mock-store\"><code>MockStore</code></a> and <a href=\"/guide/store/testing#using-mock-selectors\"><code>MockSelectors</code></a> to test Effects that are selecting slices of the state.</p>\n<p>An example of this is to not fetch an entity (customer in this case) when it's already in the store state.</p>\n<code-example header=\"my.effects.spec.ts\">\nlet actions$: Observable&#x3C;Action>;\n\nTestBed.configureTestingModule({\n  providers: [\n    CustomersEffects,\n    provideMockActions(() => actions$),\n    // mock the Store and the selectors that are used within the Effect\n    provideMockStore({\n      selectors: [\n        {\n          selector: selectCustomers,\n          value: {\n            Bob: { name: 'Bob' },\n          },\n        },\n      ],\n    }),\n  ],\n});\n\neffects = TestBed.get&#x3C;CustomersEffects>(CustomersEffects);\n\nit('should not fetch if the user is already in the store', () => {\n  actions$ = hot('-a--', {\n    a: { type: 'GET CUSTOMER BY NAME', name: 'Bob' },\n  });\n\n  // there is no output, because Bob is already in the Store state\n  const expected = hot('----');\n\n  expect(effects.getByName$).toBeObservable(expected);\n});\n</code-example>\n<h3 id=\"setup-without-testbed\">Setup without <code>TestBed</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#setup-without-testbed\"><i class=\"material-icons\">link</i></a></h3>\n<p>Instead of using the Angular <code>TestBed</code>, we can instantiate the Effect class.</p>\n<code-example header=\"my.effects.spec.ts\">\nit('should get customers', () => {\n  // instead of using `provideMockActions`,\n  // define the actions stream by creating a new `Actions` instance\n  const actions = new Actions(\n    hot('-a--', {\n      a: { type: 'GET CUSTOMERS' },\n    })\n  );\n\n  // create the effect\n  const effects = new CustomersEffects(actions, customersServiceSpy);\n\n  // expect remains the same\n  effects.getAll$.subscribe(action => {\n    expect(action).toEqual({\n      type: 'GET CUSTOMERS SUCCESS',\n      customers: [...],\n    });\n  });\n})\n</code-example>\n<p>For an Effect with store interaction, it's possible to create an Observable <code>Store</code>.</p>\n<code-example header=\"my.effects.spec.ts\">\nit('should get customers', () => {\n  // create the store, this can be just an Observable\n  const store = of({}) as Store&#x3C;Action>;\n\n  // instead of using `provideMockActions`,\n  // define the actions stream by creating a new `Actions` instance\n  const actions = new Actions(\n    hot('-a--', {\n      a: { type: 'GET CUSTOMER BY NAME', name: 'Bob' },\n    })\n  );\n\n  // mock the selector\n  selectCustomers.setResult({\n    Bob: { name: 'Bob' },\n  });\n\n  // create the effect\n  const effects = new CustomersEffects(store, actions, customersServiceSpy);\n\n  // there is no output, because Bob is already in the Store state\n  const expected = hot('----');\n\n  expect(effects.getByName$).toBeObservable(expected);\n});\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/effects\n-->\n<!-- links from this doc:\n - /guide/store/testing#using-a-mock-store\n - /guide/store/testing#using-mock-selectors\n - guide/effects/testing#a-non-dispatching-effect\n - guide/effects/testing#effect-that-uses-state\n - guide/effects/testing#effects-with-parameters\n - guide/effects/testing#examples\n - guide/effects/testing#marble-diagrams\n - guide/effects/testing#providemockactions\n - guide/effects/testing#setup-without-testbed\n - guide/effects/testing#test-helpers\n - guide/effects/testing#testing\n - guide/effects/testing#testing-practices\n - guide/effects/testing#with-observables\n - guide/effects/testing#with-replaysubject\n - https://github.com//edit/master/NODEJS/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\n - https://rxjs.dev/guide/testing/marble-testing\n - https://www.npmjs.com/package/jasmine-marbles\n-->"
}