{
  "id": "guide/effects/testing",
  "title": "Testing",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#testing\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"test-helpers\">Test helpers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#test-helpers\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"providemockactions\"><code>provideMockActions</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#providemockactions\"><i class=\"material-icons\">link</i></a></h3>\n<p>An Effect subscribes to the <code>Actions</code> Observable to perform side effects.\n<code>provideMockActions</code> provides a mock provider of the <code>Actions</code> Observable to subscribe to, for each test individually.</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { provideMockActions } from '@ngrx/effects/testing';\n\nlet actions$ = new Observable&#x3C;Action>();\n\nTestBed.configureTestingModule({\n  providers: [provideMockActions(() => actions$)],\n});\n</code-example>\n<p>Later in the test cases, we assign the <code>actions$</code> variable to a stream of actions.</p>\n<code-example header=\"my.effects.spec.ts\">\n// by creating an Observable\nactions$ = of({ type: 'Action One' });\n\n// or by using a marble diagram\nactions$ = hot('--a-', { a: { type: 'Action One' } });\n</code-example>\n<h3 id=\"effects-with-parameters\">Effects with parameters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effects-with-parameters\"><i class=\"material-icons\">link</i></a></h3>\n<p>For time dependant effects, for example <code>debounceTime</code>, we must be able override the default RxJS scheduler with the <code>TestScheduler</code> during our test.\nThat's why we create the effect as a function with parameters. By doing this we can assign default parameter values for the effect, and override these values later in the test cases.</p>\n<p>This practice also allows us to hide the implementation details of the effect.\nIn the <code>debounceTime</code> test case, we can we can set the debounce time to a controlled value.</p>\n<code-example header=\"my.effects.ts\">\nsearch$ = createEffect(() => ({\n  // assign default values\n  debounce = 300,\n  scheduler = asyncScheduler\n} = {}) =>\n  this.actions$.pipe(\n    ofType(BookActions.search),\n    debounceTime(debounce, scheduler),\n    ...\n  )\n);\n</code-example>\n<code-example header=\"my.effects.spec.ts\">\n// override the default values\neffects.search$({\n  debounce: 30,\n  scheduler: getTestScheduler(),\n});\n</code-example>\n<h2 id=\"testing-practices\">Testing practices<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#testing-practices\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"marble-diagrams\">Marble diagrams<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#marble-diagrams\"><i class=\"material-icons\">link</i></a></h3>\n<p>Testing Effects via marble diagrams is particularly useful when the Effect is time sensitive or when the Effect has a lot of behavior.</p>\n<div class=\"alert is-helpful\">\n<p>For a detailed look on the marble syntax, see <a href=\"https://rxjs.dev/guide/testing/marble-testing\">Writing marble tests</a>.</p>\n<p>The <code>hot</code>, <code>cold</code>, and <code>toBeObservable</code> methods are imported from <a href=\"https://www.npmjs.com/package/jasmine-marbles\"><code>jasmine-marbles</code></a>.</p>\n</div>\n<code-example header=\"my.effects.spec.ts\">\n// create an actions stream to represent a user that is typing\nactions$ = hot('-a-b-', {\n  a: { type: '[Customers Page] Search Customers', name: 'J' },\n  b: { type: '[Customers Page] Search Customers', name: 'Jes' },\n})\n\n// mock the service to prevent an HTTP request to return an array of customers\ncustomersServiceSpy.searchCustomers.and.returnValue(\n  cold('--a|', { a: [...] })\n);\n\n// expect the first action to debounce and not to dispatch\n// expect the second action to result in a SUCCESS action\nconst expected = hot('-------a', {\n  a: {\n    type: '[Customers API] Search Customers Success',\n    customers: [...],\n  },\n});\n\nexpect(\n  effects.searchCustomers$({\n    debounce: 20,\n    scheduler: getTestScheduler(),\n  })\n).toBeObservable(expected);\n</code-example>\n<h3 id=\"with-testscheduler\">With <code>TestScheduler</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#with-testscheduler\"><i class=\"material-icons\">link</i></a></h3>\n<p>Instead of using <code>jasmine-marbles</code>, we can also run tests with the <a href=\"https://rxjs.dev/guide/testing/marble-testing\">RxJS <code>TestScheduler</code></a>.</p>\n<p>To use the <code>TestScheduler</code> we first have to instantiate it,\nthis can be done in the test case or within a <code>beforeEach</code> block.</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestScheduler } from 'rxjs/testing';\n\nlet testScheduler: TestScheduler;\n\nbeforeEach(() => {\n  testScheduler = new TestScheduler((actual, expected) => {\n    expect(actual).toEqual(expected);\n  });\n});\n</code-example>\n<p>The <code>TestScheduler</code> provides a <code>run</code> method which expects a callback, it's here where we write the test for an effect.\nThe callback method provides helper methods to mock Observable streams, and also assertion helper methods to verify the output of a stream.</p>\n<code-example header=\"my.effects.spec.ts\">\n// more info about the API can be found at https://rxjs.dev/guide/testing/marble-testing#api\ntestScheduler.run(({ cold, hot, expectObservable }) => {\n  // use the `hot` and `cold` helper methods to create the action and service streams\n  actions$ = hot('-a', { a : { type: '[Customers Page] Get Customers' }});\n  customersServiceSpy.getAllCustomers.and.returnValue(cold('--a|', { a: [...] }));\n\n  // use the `expectObservable` helper method to assert if the output matches the expected output\n  expectObservable(effects.getAll$).toBe('---c', {\n    c: {\n      type: '[Customers API] Get Customers Success',\n      customers: [...],\n    }\n  });\n});\n</code-example>\n<p>By using the <code>TestScheduler</code> we can also test effects dependant on a scheduler.\nInstead of creating an effect as a method to override properties in test cases, as shown in <a href=\"guide/effects/testing#effects-with-parameters\"><code>Effects with parameters</code></a>, we can rewrite the test case by using the <code>TestScheduler</code>.</p>\n<code-example header=\"my.effects.spec.ts\">\ntestScheduler.run(({ cold, hot, expectObservable }) => {\n  // create an actions stream to represent a user that is typing\n  actions$ = hot('-a-b-', {\n    a: { type: '[Customers Page] Search Customers', name: 'J' },\n    b: { type: '[Customers Page] Search Customers', name: 'Jes' },\n  })\n\n  // mock the service to prevent an HTTP request to return an array of customers\n  customersServiceSpy.searchCustomers.and.returnValue(\n    cold('--a|', { a: [...] })\n  );\n\n  // the `300ms` is the set debounce time\n  // the `5ms` represents the time for the actions stream and the service to return a value\n  expectObservable(effects.searchCustomers).toBe('300ms 5ms c', {\n    c: {\n      type: '[Customers API] Search Customers Success',\n      customers: [...],\n    },\n  });\n});\n</code-example>\n<h3 id=\"with-observables\">With Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#with-observables\"><i class=\"material-icons\">link</i></a></h3>\n<p>To test simple Effects, it might be easier to create an Observable instead of using a marble diagram.</p>\n<code-example header=\"my.effects.spec.ts\">\n// create an actions stream and immediately dispatch a GET action\nactions$ = of({ type: '[Customers Page] Get Customers' });\n\n// mock the service to prevent an HTTP request\ncustomersServiceSpy.getAllCustomers.and.returnValue(of([...]));\n\n// subscribe to the Effect stream and verify it dispatches a SUCCESS action\neffects.getAll$.subscribe(action => {\n  expect(action).toEqual({\n    type: '[Customers API] Get Customers Success',\n    customers: [...],\n  });\n});\n</code-example>\n<h3 id=\"with-replaysubject\">With <code>ReplaySubject</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#with-replaysubject\"><i class=\"material-icons\">link</i></a></h3>\n<p>As an alternative, it's also possible to use <code>ReplaySubject</code>.</p>\n<code-example header=\"my.effects.spec.ts\">\n// create a ReplaySubject\nactions$ = new ReplaySubject(1);\n\n// mock the service to prevent an HTTP request\ncustomersServiceSpy.getAllCustomers.and.returnValue(of([...]));\n\n// dispatch the GET action\n(actions$ as ReplaySubject).next({ type: '[Customers Page] Get Customers' })\n\n// subscribe to the Effect stream and verify it dispatches a SUCCESS action\neffects.getAll$.subscribe(action => {\n  expect(action).toEqual({\n    type: '[Customers API] Get Customers Success',\n    customers: [...],\n  });\n});\n</code-example>\n<h2 id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#examples\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"a-non-dispatching-effect\">A non-dispatching Effect<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#a-non-dispatching-effect\"><i class=\"material-icons\">link</i></a></h3>\n<p>Until now, we only saw Effects that dispatch an Action and we verified the dispatched action.\nWith an Effect that does not dispatch an action, we can't verify the Effects stream.\nWhat we can do, is verify the side-effect has been called.</p>\n<p>An example of this is to verify we navigate to the correct page.</p>\n<code-example header=\"my.effects.spec.ts\">\nit('should navigate to the customers detail page', () => {\n  actions$ = of({ type: '[Customers Page] Customer Selected', name: 'Bob' });\n  \n  // create a spy to verify the navigation will be called\n  spyOn(router, 'navigateByUrl');\n\n  // subscribe to execute the Effect\n  effects.selectCustomer$.subscribe();\n\n  // verify the navigation has been called\n  expect(router.navigateByUrl).toHaveBeenCalledWith('customers/bob');\n});\n</code-example>\n<h3 id=\"effect-that-uses-state\">Effect that uses state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effect-that-uses-state\"><i class=\"material-icons\">link</i></a></h3>\n<p>Leverage <a href=\"/guide/store/testing#using-a-mock-store\"><code>MockStore</code></a> and <a href=\"/guide/store/testing#using-mock-selectors\"><code>MockSelectors</code></a> to test Effects that are selecting slices of the state.</p>\n<p>An example of this is to not fetch an entity (customer in this case) when it's already in the store state.</p>\n<code-example header=\"my.effects.spec.ts\">\nlet actions$: Observable&#x3C;Action>;\n\nTestBed.configureTestingModule({\n  providers: [\n    CustomersEffects,\n    provideMockActions(() => actions$),\n    // mock the Store and the selectors that are used within the Effect\n    provideMockStore({\n      selectors: [\n        {\n          selector: selectCustomers,\n          value: {\n            Bob: { name: 'Bob' },\n          },\n        },\n      ],\n    }),\n  ],\n});\n\neffects = TestBed.inject&#x3C;CustomersEffects>(CustomersEffects);\n\nit('should not fetch if the user is already in the store', () => {\n  actions$ = hot('-a--', {\n    a: { type: '[Customers Page] Search Customers', name: 'Bob' },\n  });\n\n  // there is no output, because Bob is already in the Store state\n  const expected = hot('----');\n\n  expect(effects.getByName$).toBeObservable(expected);\n});\n</code-example>\n<h3 id=\"setup-without-testbed\">Setup without <code>TestBed</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#setup-without-testbed\"><i class=\"material-icons\">link</i></a></h3>\n<p>Instead of using the Angular <code>TestBed</code>, we can instantiate the Effect class.</p>\n<code-example header=\"my.effects.spec.ts\">\nit('should get customers', () => {\n  // instead of using `provideMockActions`,\n  // define the actions stream by creating a new `Actions` instance\n  const actions = new Actions(\n    hot('-a--', {\n      a: { type: '[Customers Page] Get Customers' },\n    })\n  );\n\n  // create the effect\n  const effects = new CustomersEffects(actions, customersServiceSpy);\n\n  // expect remains the same\n  effects.getAll$.subscribe(action => {\n    expect(action).toEqual({\n      type: '[Customers API] Get Customers Success',\n      customers: [...],\n    });\n  });\n})\n</code-example>\n<p>For an Effect with store interaction, it's possible to create an Observable <code>Store</code>.</p>\n<code-example header=\"my.effects.spec.ts\">\nit('should get customers', () => {\n  // create the store, this can be just an Observable\n  const store = of({}) as Store&#x3C;Action>;\n\n  // instead of using `provideMockActions`,\n  // define the actions stream by creating a new `Actions` instance\n  const actions = new Actions(\n    hot('-a--', {\n      a: { type: '[Search Customers Page] Get Customer', name: 'Bob' },\n    })\n  );\n\n  // mock the selector\n  selectCustomers.setResult({\n    Bob: { name: 'Bob' },\n  });\n\n  // create the effect\n  const effects = new CustomersEffects(store, actions, customersServiceSpy);\n\n  // there is no output, because Bob is already in the Store state\n  const expected = hot('----');\n\n  expect(effects.getByName$).toBeObservable(expected);\n});\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/effects\n-->\n<!-- links from this doc:\n - /guide/store/testing#using-a-mock-store\n - /guide/store/testing#using-mock-selectors\n - guide/effects/testing#a-non-dispatching-effect\n - guide/effects/testing#effect-that-uses-state\n - guide/effects/testing#effects-with-parameters\n - guide/effects/testing#examples\n - guide/effects/testing#marble-diagrams\n - guide/effects/testing#providemockactions\n - guide/effects/testing#setup-without-testbed\n - guide/effects/testing#test-helpers\n - guide/effects/testing#testing\n - guide/effects/testing#testing-practices\n - guide/effects/testing#with-observables\n - guide/effects/testing#with-replaysubject\n - guide/effects/testing#with-testscheduler\n - https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\n - https://rxjs.dev/guide/testing/marble-testing\n - https://www.npmjs.com/package/jasmine-marbles\n-->"
}