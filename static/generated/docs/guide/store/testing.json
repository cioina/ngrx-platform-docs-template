{
  "id": "guide/store/testing",
  "title": "Testing",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/store/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/testing#testing\"><i class=\"material-icons\">link</i></a></h1>\n<h3 id=\"using-a-mock-store\">Using a Mock Store<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/testing#using-a-mock-store\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>provideMockStore()</code> function registers providers that allow you to mock out the <code>Store</code> for testing functionality that has a dependency on <code>Store</code> without setting up reducers.\nYou can write tests validating behaviors corresponding to the specific state snapshot easily.</p>\n<div class=\"alert is-helpful\">\n<p><strong>Note:</strong> All dispatched actions don't affect the state, but you can see them in the <code>Actions</code> stream.</p>\n</div>\n<p>Usage:</p>\n<code-example header=\"auth.guard.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { provideMockStore, MockStore } from '@ngrx/store/testing';\nimport { cold } from 'jasmine-marbles';\n\nimport { AuthGuard } from '../guards/auth.guard';\n\ndescribe('Auth Guard', () => {\n  let guard: AuthGuard;\n  let store: MockStore;\n  const initialState = { loggedIn: false };\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        // any modules needed\n      ],\n      providers: [\n        AuthGuard,\n        provideMockStore({ initialState }),\n        // other providers\n      ],\n    });\n\n    store = TestBed.inject(MockStore);\n    guard = TestBed.inject(AuthGuard);\n  });\n\n  it('should return false if the user state is not logged in', () => {\n    const expected = cold('(a|)', { a: false });\n\n    expect(guard.canActivate()).toBeObservable(expected);\n  });\n\n  it('should return true if the user state is logged in', () => {\n    store.setState({ loggedIn: true });\n\n    const expected = cold('(a|)', { a: true });\n\n    expect(guard.canActivate()).toBeObservable(expected);\n  });\n});\n</code-example>\n<h3 id=\"using-mock-selectors\">Using Mock Selectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/testing#using-mock-selectors\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>MockStore</code> also provides the ability to mock individual selectors to return a passed value using the <code>overrideSelector()</code> method. When the selector is invoked by the <code>select</code> method, the returned value is overridden by the passed value, regardless of the current state in the store.</p>\n<p><code>overrideSelector()</code> returns a <code>MemoizedSelector</code>. To update the mock selector to return a different value, use the <code>MemoizedSelector</code>'s <code>setResult()</code> method. Updating a selector's mock value will not cause it to emit automatically. To trigger an emission from all selectors, use the <code>MockStore.refreshState()</code> method after updating the desired selectors.</p>\n<p><code>overrideSelector()</code> supports mocking the <code>select</code> method (used in RxJS pipe) and the <code>Store</code> <code>select</code> instance method using a string or selector.</p>\n<p>Usage:</p>\n<code-example header=\"user-greeting.component.ts\" path=\"testing-store/src/app/user-greeting.component.ts\">\nimport { Component } from '@angular/core';\nimport { select, Store } from '@ngrx/store';\nimport * as fromAuth from './reducers';\n\n@Component({\n  selector: 'user-greeting',\n  template: `\n    &#x3C;div>Greetings, {{ username$ | async }}!&#x3C;/div>\n  `,\n})\nexport class UserGreetingComponent {\n  username$ = this.store.pipe(select(fromAuth.getUsername));\n\n  constructor(private store: Store&#x3C;fromAuth.State>) {}\n}\n\n\n</code-example>\n<code-example header=\"user-greeting.component.spec.ts\" path=\"testing-store/src/app/user-greeting.component.spec.ts\">\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { By } from '@angular/platform-browser';\nimport { MemoizedSelector } from '@ngrx/store';\nimport { provideMockStore, MockStore } from '@ngrx/store/testing';\nimport { UserGreetingComponent } from './user-greeting.component';\nimport * as fromAuth from './reducers';\n\ndescribe('User Greeting Component', () => {\n  let fixture: ComponentFixture&#x3C;UserGreetingComponent>;\n  let mockStore: MockStore;\n  let mockUsernameSelector: MemoizedSelector&#x3C;fromAuth.State, string>;\n  const queryDivText = () =>\n    fixture.debugElement.queryAll(By.css('div'))[0].nativeElement.textContent;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [provideMockStore()],\n      declarations: [UserGreetingComponent],\n    });\n\n    fixture = TestBed.createComponent(UserGreetingComponent);\n    mockStore = TestBed.inject(MockStore);\n    mockUsernameSelector = mockStore.overrideSelector(\n      fromAuth.getUsername,\n      'John'\n    );\n    fixture.detectChanges();\n  });\n\n  it('should greet John when the username is John', () => {\n    expect(queryDivText()).toBe('Greetings, John!');\n  });\n\n  it('should greet Brandon when the username is Brandon', () => {\n    mockUsernameSelector.setResult('Brandon');\n    mockStore.refreshState();\n    fixture.detectChanges();\n    expect(queryDivText()).toBe('Greetings, Brandon!');\n  });\n});\n\n\n</code-example>\n<p>In this example, we mock the <code>getUsername</code> selector by using <code>overrideSelector</code>, passing in the <code>getUsername</code> selector with a default mocked return value of <code>'John'</code>. In the second test, we use <code>setResult()</code> to update the mock selector to return <code>'Brandon'</code>, then we use <code>MockStore.refreshState()</code> to trigger an emission from the <code>getUsername</code> selector.</p>\n<div class=\"alert is-helpful\">\n<p><strong>Note:</strong> <code>MockStore</code> will reset all of the mocked selectors after each test (in the <code>afterEach()</code> hook) by calling the <code>MockStore.resetSelectors()</code> method.</p>\n</div>\n<p>Try the <live-example name=\"testing-store\"></live-example>.</p>\n<h3 id=\"integration-testing\">Integration Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/testing#integration-testing\"><i class=\"material-icons\">link</i></a></h3>\n<p>An integration test should verify that the <code>Store</code> coherently works together with our components and services that inject <code>Store</code>. An integration test will not mock the store or individual selectors, as unit tests do, but will instead integrate a <code>Store</code> by using <code>StoreModule.forRoot</code> in your <code>TestBed</code> configuration. Here is an example of an integration test for the <code>MyCounterComponent</code> introduced in the <a href=\"guide/store#tutorial\">getting started tutorial</a>.</p>\n<code-example header=\"src/app/tests/integration.spec.ts\" path=\"store/src/app/tests/integration.spec.ts\">\nimport { TestBed, async, ComponentFixture } from '@angular/core/testing';\nimport { By } from '@angular/platform-browser';\nimport { StoreModule } from '@ngrx/store';\nimport { MyCounterComponent } from '../my-counter/my-counter.component';\nimport { counterReducer } from '../counter.reducer';\n\ndescribe('MyCounterComponent', () => {\n  let component: MyCounterComponent;\n  let fixture: ComponentFixture&#x3C;MyCounterComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ MyCounterComponent ],\n      imports: [\n        StoreModule.forRoot({ count: counterReducer })\n      ]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(MyCounterComponent);\n    component = fixture.debugElement.componentInstance;\n    fixture.detectChanges();\n  }));\n\n  it('should create the component', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should increment the counter value when increment is clicked', () => {\n    clickByCSS('#increment');\n\n    expect(getCounterText()).toBe(\n      'Current Count: 1'\n    );\n  });\n\n  it('should decrement the counter value when decrement is clicked', () => {\n    clickByCSS('#decrement');\n\n    expect(getCounterText()).toBe(\n      'Current Count: -1'\n    );\n  });\n\n  it('should reset the counter value when reset is clicked', () => {\n    clickByCSS('#increment');\n    clickByCSS('#reset');\n\n    expect(getCounterText()).toBe(\n      'Current Count: 0'\n    );\n  });\n\n  function clickByCSS(selector: string) {\n    const debugElement = fixture.debugElement.query(By.css(selector));\n    const el: HTMLElement = debugElement.nativeElement;\n    el.click();\n    fixture.detectChanges();\n  }\n\n  function getCounterText() {\n    const compiled = fixture.debugElement.nativeElement;\n    return compiled.querySelector('div').textContent;\n  }\n});\n\n\n</code-example>\n<p>The integration test sets up the dependent <code>Store</code> by importing the <code>StoreModule</code>. In this example, we assert that clicking a button dispatches an action that causes the state to be updated with an incremented, decremented, or reset counter value, which is correctly emitted by the selector.</p>\n<h3 id=\"testing-selectors\">Testing selectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/testing#testing-selectors\"><i class=\"material-icons\">link</i></a></h3>\n<p>You can use the projector function used by the selector by accessing the <code>.projector</code> property.</p>\n<code-example header=\"my.selectors.ts\">\nexport interface State {\n  evenNums: number[];\n  oddNums: number[];\n}\n\nexport const selectSumEvenNums = createSelector(\n  (state: State) => state.evenNums,\n  evenNums => evenNums.reduce((prev, curr) => prev + curr)\n);\nexport const selectSumOddNums = createSelector(\n  (state: State) => state.oddNums,\n  oddNums => oddNums.reduce((prev, curr) => prev + curr)\n);\nexport const selectTotal = createSelector(\n  selectSumEvenNums,\n  selectSumOddNums,\n  (evenSum, oddSum) => evenSum + oddSum\n);\n</code-example>\n<code-example header=\"my.selectors.spec.ts\">\nimport * as fromMyReducers from './my-reducers';\n\ndescribe('My Selectors', () => {\n  it('should calc selectTotal', () => {\n    expect(fromMyReducers.selectTotal.projector(2, 3)).toBe(5);\n  });\n});\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/store#tutorial\n - guide/store/testing#integration-testing\n - guide/store/testing#testing\n - guide/store/testing#testing-selectors\n - guide/store/testing#using-a-mock-store\n - guide/store/testing#using-mock-selectors\n - https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/store/testing.md?message=docs%3A%20describe%20your%20change...\n-->"
}