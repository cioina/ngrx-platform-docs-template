{
  "id": "guide/data/save-entities",
  "title": "Saving Multiple Entities",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/data/save-entities.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"saving-multiple-entities\">Saving Multiple Entities<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#saving-multiple-entities\"><i class=\"material-icons\">link</i></a></h1>\n<p>Many apps must save several entities at the same time in the same transaction.</p>\n<p>Multiple entity saves are a first class feature.\nBy \"first class\" we mean that NgRx Data offers a built-in, multiple entity save solution that\nis consistent with NgRx Data itself:</p>\n<ul>\n<li>defines a <code>ChangeSet</code>, describing <code>ChangeOperations</code> to be performed on multiple entities of multiple types.</li>\n<li>has a set of <code>SAVE_ENTITIES...</code> cache-level actions.</li>\n<li>has an <code>EntityCacheDispatcher</code> to dispatch those actions.</li>\n<li>offers <code>EntityCacheEffects</code> that sends <code>SAVE_ENTITIES</code> async requests to the server and\nreturns results as <code>SAVE_ENTITIES_SUCCESS</code> or <code>SAVE_ENTITIES_ERROR</code> actions.</li>\n<li>offers a default <code>EntityCacheDataService</code> to make those http server requests.</li>\n<li>integrates with change tracking.</li>\n<li>delegates each collection-level change to the (customizable) <code>entity-collection-reducer-methods</code>.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p>You could implement multiple-entity saves yourself by, prior to version 6.1.\nYou could define your own protocol and manipulate the <code>EntityCache</code> directly by dispatching <code>SET_ENTITY_CACHE</code>\nafter updating a copy of the current cache before and after save.\nThe collection-level reducers in <code>entity-collection-reducer-methods</code> and the NgRx <code>EntityAdapters</code> would help.</p>\n<p>It wouldn't be easy and there are many steps that can be easily overlooked. But you could do it.</p>\n</div>\n<h3 id=\"save-with-entitycachedispatchersaveentities\">Save with <em>EntityCacheDispatcher.saveEntities()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#save-with-entitycachedispatchersaveentities\"><i class=\"material-icons\">link</i></a></h3>\n<p>This NgRx Data version includes a new <code>EntityCacheDispatcher</code> whose\nmethods make it easier to create and dispatch all of the entity cache actions.</p>\n<p>Save a bunch of entity changes with the <code>saveEntities()</code> dispatcher method.\nCall it with a URL and a <code>ChangeSet</code> describing the entity changes that the server API (at the URL endpoint) should save.</p>\n<p>The sample application demonstrates a simple <code>saveEntities</code> scenario.\nA button on the <em>Villains</em> page deletes all of the villains.</p>\n<p>In the following example, we want to add a <code>Hero</code> and delete two <code>Villains</code> in the same transaction.\nWe assume a server is ready to handle such a request.</p>\n<p>First create the changes (each a <code>ChangeSetItem</code>) for the <code>ChangeSet</code>.</p>\n<code-example linenums=\"false\">\nimport { ChangeSetOperation } from '@ngrx/data';\n...\nconst changes: ChangeSetItem[] = [\n  {\n    op: ChangeSetOperation.Add,\n    entityName: 'Hero',\n    entities: [hero]\n  },\n  {\n    op: ChangeSetOperation.Delete,\n    entityName: 'Villain',\n    entities: [2, 3] // delete by their ids\n  }\n];\n</code-example>\n<p>The <code>changeSetItemFactory</code> makes it easier to write these changes.</p>\n<code-example language=\"typescript\">\nimport { changeSetItemFactory as cif } from '@ngrx/data';\n...\nconst changes: ChangeSetItem[] = [\n  cif.add('Hero', hero),\n  cif.delete('Villain', [2, 3])\n];\n</code-example>\n<p>Now dispatch a <code>saveEntities</code> with a <code>ChangeSet</code> for those changes.</p>\n<code-example language=\"typescript\">\nconst changeSet: ChangeSet = { changes, tag: 'Hello World'}\n\ncacheEntityDispatcher.saveEntities(changeSet, saveUrl).subscribe(\n  result => log('Saved ChangeSet')\n);\n</code-example>\n<p>The <code>saveEntities(changeSet, saveUrl)</code> returns an <code>Observable&#x3C;ChangeSet></code>,\nwhich emits a new <code>ChangeSet</code> after the server API (at the <code>saveUrl</code> endpoint) returns a successful response.</p>\n<p>That emitted <code>ChangeSet</code> holds the server's response data for all affected entities.</p>\n<p>The app can wait for the <code>saveEntities()</code> observable to terminate (either successfully or with an error), before proceeding (e.g., routing to another page).</p>\n<h4 id=\"how-it-works\">How it works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#how-it-works\"><i class=\"material-icons\">link</i></a></h4>\n<p>Internally, the method creates a <code>SAVE_ENTITIES</code> action whose payload data includes the <code>ChangeSet</code>.\nThe action also has the URL to which the requested save should be sent and a <code>correlationId</code> (see below).</p>\n<p>The method dispatches this action to the NgRx store where it is processed by the <code>EntityCacheReducer</code>.\nIf the action is \"optimistic\", the reducer updates the cache with changes immediately.</p>\n<p>Then the <code>EntityCacheEffects</code> picks up the <code>SAVE_ENTITIES</code> action and sends a \"save changes\" request to\nthe server's API endpoint (the URL).</p>\n<p>If the request succeeds, the server returns data for all of the changed (and deleted) entities.\nThe <code>EntityCacheEffects</code> packages that data into a <code>SAVE_ENTITIES_SUCCESS</code> action and dispatches it to the store.</p>\n<p>The <code>EntityCacheReducer</code> for the <code>SAVE_ENTITIES_SUCCESS</code> action\nupdates the cache with the (possibly altered) entity data from the server.</p>\n<p>Meanwhile, the <code>Observable&#x3C;ChangeSet></code> from the <code>saveEntities()</code> dispatcher method is\nwatching the stream of actions dispatched to the store.\nWhen a <code>SAVE_ENTITIES_SUCCESS</code> (or <code>SAVE_ENTITIES_ERROR</code>) action emerges and\nit has the same <code>correlationId</code> as the original <code>SAVE_ENTITIES</code> action,\nthe observable emits the <code>ChangeSet</code> (or error).</p>\n<p>The subscriber to that observable now knows that this particular <em>save entities</em> request is \"done\".</p>\n<div class=\"alert is-helpful\">\n<p>This complicated dance is standard NgRx. Fortunately, all you have to know is that you can call <code>saveEntities()</code> with the <code>ChangeSet</code> and URL, then wait for the returned observable to emit.</p>\n</div>\n<h4 id=\"changeset\"><em>ChangeSet</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#changeset\"><i class=\"material-icons\">link</i></a></h4>\n<p>The <code>ChangeSet</code> interface is a simple structure with only one critical property,\n<code>changes</code>, which holds the entity data to save.</p>\n<code-example header=\"ChangeSet\" linenums=\"false\">\n\nexport interface ChangeSet&#x3C;T = any> {\n  /** An array of ChangeSetItems to be processed in the array order */\n  changes: ChangeSetItem[];\n\n  /**\n   * An arbitrary, serializable object that should travel with the ChangeSet.\n   * Meaningful to the ChangeSet producer and consumer. Ignored by NgRx Data.\n   */\n  extras?: T;\n\n  /** An arbitrary string, identifying the ChangeSet and perhaps its purpose */\n  tag?: string;\n}\n\n</code-example>\n<p>At the heart of it is <code>changes</code>, an array of <code>ChangeSetItems</code> that describes a change operation to be performed with one or more entities of a particular type.</p>\n<p>For example,</p>\n<ul>\n<li>a <code>ChangeSetAdd</code> could add 3 new <code>Hero</code> entities to the server's <code>Hero</code> collection.</li>\n<li>a <code>ChangeSetUpdate</code> could update 2 existing <code>Villain</code> entities.</li>\n<li>a <code>ChangeSetDelete</code> could delete a <code>SideKick</code> entity by its primary key.</li>\n<li>a <code>ChangeSetUpsert</code> could add two new <code>SuperPower</code> entities and update a third <code>SuperPower</code> entity.</li>\n</ul>\n<p>There are four <code>ChangeSetOperations</code></p>\n<code-example header=\"ChangeSetOperation\">\nexport enum ChangeSetOperation {\n  Add = 'Add',\n  Delete = 'Delete',\n  Update = 'Update',\n  Upsert = 'Upsert'\n}\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>Upsert</code> is a request to treat the entities in the <code>ChangeSetItem</code> as <em>either</em> new entities or updates to <em>existing</em> entities.</p>\n</div>\n<p>Each kind of <code>ChangeSetItem</code> follows a pattern similar to <code>ChangeSetAdd</code>.</p>\n<code-example header=\"ChangeSetAdd\">\nexport interface ChangeSetAdd&#x3C;T = any> {\n  op: ChangeSetOperation.Add;\n  entityName: string;\n  entities: T[];\n}\n</code-example>\n<p>The <code>ChangeSetItem</code> flavors all have <code>op</code>, <code>entityName</code> and <code>entities</code> properties.\nThey differ substantively only in the nature of the <code>entities</code> array which corresponds to the change operation:</p>\n<ul>\n<li>Add: entities</li>\n<li>Delete: primary keys of the entities to delete</li>\n<li>Update: NgRx Entity <code>Update&#x3C;T></code>s</li>\n<li>Upsert: entities</li>\n</ul>\n<h4 id=\"pessimistic--optimistic-save\">Pessimistic / Optimistic save<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#pessimistic--optimistic-save\"><i class=\"material-icons\">link</i></a></h4>\n<p>The <code>EntityCacheDispatcher.saveEntities</code> dispatches the <code>SAVE_ENTITIES</code> action (with its <code>ChangeSet</code>) to the store where it is processed by the <code>EntityCacheReducer</code>.</p>\n<p>If the action is \"pessimistic\", the reducer sets the collection <code>loading</code> flags but doesn't update the entities in cache.\nThe reducer for the <code>SAVE_ENTITIES_SUCCESS</code> action, whose payload holds the successfully saved entities, will update the cached entities.</p>\n<p>If the action is \"optimistic\", the reducer applies the changes to the cache immediately, before you send them to the server.</p>\n<p>You can specify \"optimistic\" or \"pessimistic\" in the <code>options</code> parameter.\nIf you don't specify this option, NgRx Data uses the default value in\n<code>EntityDispatcherDefaultOptions.optimisticSaveEntities</code>.\nIt is <code>false</code> (pessimistic) by default.</p>\n<h4 id=\"specify-your-own-defaults\">Specify your own defaults<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#specify-your-own-defaults\"><i class=\"material-icons\">link</i></a></h4>\n<p>You can provide alternative defaults.</p>\n<code-example language=\"typescript\">\n {\n  provide: EntityDispatcherDefaultOptions,\n  useValue: myDispatcherDefaultOptions\n}\n</code-example>\n<h4 id=\"server\">Server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#server\"><i class=\"material-icons\">link</i></a></h4>\n<p>The server API (the usual recipient of a <code>ChangeSet</code>) must be able to process the request.\nNgRx Data doesn't know if the API can or cannot process a <code>ChangeSet</code> (and that includes whether the server can or cannot handle upserts).</p>\n<p>As always, make sure only to send something that the server API can handle.</p>\n<h4 id=\"entitycacheeffects\">EntityCacheEffects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#entitycacheeffects\"><i class=\"material-icons\">link</i></a></h4>\n<p>You can handle the async HTTP <em>save changes</em> request yourself, making your own calls to the server in your own way.</p>\n<p>Your solution can use the <code>EntityCacheDispacher</code> to dispatch <code>SAVE_ENTITIES</code>, <code>SAVE_ENTITIES_SUCCESS</code> and <code>SAVE_ENTITIES_ERROR</code> actions for updating the cache and managing the <code>ChangeState</code> of the entities in the <code>ChangeSet</code>.</p>\n<p>Perhaps better, you can let the <code>EntityCacheEffects</code> handle this for you in a manner similar to the v6 <code>EntityEffects</code> for single-entity saves.</p>\n<p>The <code>EntityCacheEffects.saveEntities$</code> effect listens for <code>SAVE_ENTITIES</code> and makes a request to the designated URL via the (new) <code>EntityCacheDataService</code>.\nIt takes the response and dispatches either a <code>SAVE_ENTITIES_SUCCESS</code> or <code>SAVE_ENTITIES_ERROR</code>, as appropriate.</p>\n<div class=\"alert is-helpful\">\n<p>If you prefer to handle server interaction yourself,\nyou can disable the <code>EntityCacheEffects</code> by providing a null implementation, in your <code>NgModule</code>, e.g.,</p>\n<code-example language=\"typescript\">\n{ provide: EntityCacheEffects: useValue: {} }\n</code-example>\n</div>\n<h4 id=\"entitycachedataservice\">EntityCacheDataService<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#entitycachedataservice\"><i class=\"material-icons\">link</i></a></h4>\n<p>The <code>EntityCacheDataService</code> constructs and POSTS the actual request to the given API URL.</p>\n<p>We anticipate that most server API implementors will not support the NgRx Entity <code>Update</code> structure within the <code>ChangeSet</code>.\nSo the <code>EntityCacheDataService.saveEntities()</code> method\nextracts the <code>changes</code> from the <code>Updates&#x3C;T>[]</code> and sends these to the server; it then reconstructs the <code>Updates&#x3C;T>[]</code> entities in from the server response so that the NgRx Data consumer of the response sees those <code>Update</code> structures.</p>\n<p>As always, you can provide an alternative implementation:</p>\n<code-example language=\"typescript\">\n{ provide: EntityCacheDataService: useClass: MyCacheDataService }\n</code-example>\n<h4 id=\"updating-the-store-with-server-response-data\">Updating the store with server response data<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#updating-the-store-with-server-response-data\"><i class=\"material-icons\">link</i></a></h4>\n<p>If the save was pessimistic, the EntityCache is unchanged until the server responds.\nYou need the results from the server to update the cache.</p>\n<div class=\"alert is-helpful\">\n<p>The changes are already in cache with an optimistic save.\nBut the server might have made additional changes to the data,\nin which case you'd want to (re)apply the server response data to cache.</p>\n</div>\n<p>The server API is supposed to return all changed entity data in the\nform of a <code>ChangeSet</code>.</p>\n<p>Often the server processes the saved entities without changing them.\nThere's no real need for the server to return the data.\nThe original request <code>ChangeSet</code> has all the information necessary to update the cache.\nResponding with a <code>\"204-No Content\"</code> instead would save time, bandwidth, and processing.</p>\n<p>The server can respond <code>\"204-No Content\"</code> and send back nothing.\nThe <code>EntityCacheEffects</code> recognizes this condition and\nreturns a success action <em>derived</em> from the original request <code>ChangeSet</code>.</p>\n<p>If the save was pessimistic, it returns a <code>SaveEntitiesSuccess</code> action with the original <code>ChangeSet</code> in the payload.</p>\n<p>If the save was optimistic, the changes are already in the cache and there's no point in updating the cache.\nInstead, the effect returns a merge observable that clears the loading flags\nfor each entity type in the original <code>CacheSet</code>.</p>\n<h4 id=\"new-entityops-for-multiple-entity-save\">New <em>EntityOPs</em> for multiple entity save<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#new-entityops-for-multiple-entity-save\"><i class=\"material-icons\">link</i></a></h4>\n<p>When the server responds with a <code>ChangeSet</code>, or the effect re-uses the original request <code>ChangeSet</code>, the effect returns a <code>SAVE_ENTITIES_SUCCESS</code> action with the <code>ChangeSet</code> in the payload.</p>\n<p>This <code>ChangeSet</code> has the same structure as the one in the <code>SAVE_ENTITIES</code> action, which was the source of the HTTP request.</p>\n<p>The <code>EntityCacheReducer</code> converts the <code>ChangeSet.changes</code> into\na sequence of <code>EntityActions</code> to the entity collection reducers.</p>\n<p>The <code>store</code> never sees these reducer calls (and you won't see them in the redux tools).\nThey are applied synchronously, in succession to an instance of the <code>EntityCache</code> object.</p>\n<p>After all <code>ChangeSet.changes</code> have been reduced, the <code>EntityCacheReducer</code> returns the updated <code>EntityCache</code> and the NgRx <code>Store</code> gets the new, fully-updated cache in one shot.</p>\n<p>That should mean that the cache is in a stable state, with all relationships updated, before any code outside the store hears of the changes.</p>\n<p>At that point, all affected entity <code>selectors$</code> will emit.</p>\n<h4 id=\"new-entityops-for-multiple-entity-save-1\">New <em>EntityOPs</em> for multiple entity save<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#new-entityops-for-multiple-entity-save-1\"><i class=\"material-icons\">link</i></a></h4>\n<p>As always, the entity collection reducers know what to do based on the <code>EntityAction.entityOp</code>.</p>\n<p>Before v6.1, the <em>save</em> <code>EntityOps</code> only worked for single entities.\nThis version adds multi-entity save actions to <code>EntityOp</code>:\n<code>SAVE_ADD_MANY...</code>,<code>SAVE_DELETE_MANY...</code>, <code>SAVE_UPDATE_MANY...</code>,<code>SAVE_UPSERT_MANY...</code>.</p>\n<div class=\"alert is-helpful\">\n<p>These ops do not have corresponding <code>EntityCommands</code> because a multi-entity save is dispatched (via <code>SAVE_ENTITIES..</code> actions) to the <code>EntityCache</code> reducer,\nnot to a collection reducer (at least not in this version).</p>\n</div>\n<h4 id=\"transactions\">Transactions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#transactions\"><i class=\"material-icons\">link</i></a></h4>\n<p>It is up to the server to process the <code>ChangeSet</code> as a transaction.\nThat's easy if the server-side store is a relational database.</p>\n<p>If your store doesn't support transactions, you'll have to decide if the multiple-entity save facility is right for you.</p>\n<p>On the NgRx Data client, it is \"transactional\" in the sense that a successful result returned by the server will be applied to the cache all at once.\nIf the server returns an error result, the cache is not touched.</p>\n<p><strong><em>Important</em></strong>: if you saved \"optimisitically\", NgRx Data updates the cache <em>before</em> sending the request to the server.</p>\n<p>NgRx Data <em>does not roll back</em> the <code>EntityCache</code> automatically when an <em>optimistic save</em> fails.</p>\n<p>Fortunately, the NgRx Data collection reducers updated the <code>ChangeState</code> of the affected entities <em>before merging</em> the changes into the cache (see the NgRx Data <code>ChangeTracker</code>).</p>\n<p>You have good options if the save fails.</p>\n<ul>\n<li>You <em>could</em> rollback using the <code>ChangeTracker</code>.</li>\n<li>You could try again.</li>\n<li>You could fail the app.</li>\n</ul>\n<p>Let your failure analysis and application business rules guide your decision.</p>\n<h4 id=\"cancellation\">Cancellation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/data/save-entities#cancellation\"><i class=\"material-icons\">link</i></a></h4>\n<p>You can try to cancel a save by dispatching the <code>SAVE_ENTITIES_CANCEL</code> action with the\n<strong>correlation id</strong> of the <em>save action</em> that you want to cancel.</p>\n<p>An optional <code>EntityNames</code> array argument tells the <code>EntityCache</code> reducer to turn off the <code>loading</code> flags\nfor the collections named in that array (these flags would have been turned on by <code>SAVE_ENTITIES</code>).\nYou can also supply a cancellation \"reason\" and the usual action tag.</p>\n<p>The <code>EntityCacheEffects.saveEntitiesCancel$</code> watches for this action and is piped into\nthe <code>EntityCacheEffects.saveEntities$</code>, where it can try to cancel the save operation\nor at least prevent the server response from updating the cache.</p>\n<div class=\"alert is-helpful\">\n<p>It's not obvious that this is ever a great idea.\nYou cannot tell the server to cancel this way and cannot know if the server did or did not save.\nNor can you count on processing the cancel request before the client receives the server response\nand applies the changes on the server or to the cache.</p>\n<p>If you cancel before the server results arrive, the <code>EntityCacheEffect</code> will not try to update\nthe cache with late arriving server results.\nThe effect will issue a <code>SAVE_ENTITIES_CANCELED</code> action instead.\nThe <code>EntityCache</code> reducer ignores this action but you can listen for it among the store actions\nand thus know that the cancellation took effect on the client.</p>\n</div>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/data/save-entities#cancellation\n - guide/data/save-entities#changeset\n - guide/data/save-entities#entitycachedataservice\n - guide/data/save-entities#entitycacheeffects\n - guide/data/save-entities#how-it-works\n - guide/data/save-entities#new-entityops-for-multiple-entity-save\n - guide/data/save-entities#new-entityops-for-multiple-entity-save-1\n - guide/data/save-entities#pessimistic--optimistic-save\n - guide/data/save-entities#save-with-entitycachedispatchersaveentities\n - guide/data/save-entities#saving-multiple-entities\n - guide/data/save-entities#server\n - guide/data/save-entities#specify-your-own-defaults\n - guide/data/save-entities#transactions\n - guide/data/save-entities#updating-the-store-with-server-response-data\n - https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/data/save-entities.md?message=docs%3A%20describe%20your%20change...\n-->"
}