{
  "id": "guide/migration/v4",
  "title": "V4 Update Guide",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/migration/v4.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"v4-update-guide\">V4 Update Guide<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#v4-update-guide\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"dependencies\">Dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#dependencies\"><i class=\"material-icons\">link</i></a></h2>\n<p>You need to have the latest versions of TypeScript and RxJS to use NgRx version 4 libraries.</p>\n<p>TypeScript 2.4.x\nRxJS 5.4.x</p>\n<h2 id=\"ngrxcore\">@ngrx/core<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#ngrxcore\"><i class=\"material-icons\">link</i></a></h2>\n<p><code>@ngrx/core</code> is no longer needed and conflicts with @ngrx/store. Remove the dependency from your project.</p>\n<p>BEFORE:</p>\n<code-example language=\"ts\">\nimport { compose } from '@ngrx/core/compose';\n</code-example>\n<p>AFTER:</p>\n<code-example language=\"ts\">\nimport { compose } from '@ngrx/store';\n</code-example>\n<h2 id=\"ngrxstore\">@ngrx/store<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#ngrxstore\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"action-interface\">Action interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#action-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>payload</code> property has been removed from the <code>Action</code> interface. It was a source of type-safety\nissues, especially when used with <code>@ngrx/effects</code>. If your interface/class has a payload, you need to provide\nthe type.</p>\n<p>BEFORE:</p>\n<code-example language=\"ts\">\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { Effect, Actions } from '@ngrx/effects';\n\n@Injectable()\nexport class MyEffects {\n  @Effect()\n  someEffect$: Observable&#x3C;Action> = this.actions$\n    .ofType(UserActions.LOGIN)\n    .pipe(\n      map(action => action.payload),\n      map(() => new AnotherAction())\n    );\n\n  constructor(private actions$: Actions) {}\n}\n</code-example>\n<p>AFTER:</p>\n<code-example language=\"ts\">\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { Effect, Actions } from '@ngrx/effects';\nimport { Login } from '../actions/auth';\n\n@Injectable()\nexport class MyEffects {\n  @Effect()\n  someEffect$: Observable&#x3C;Action> = this.actions$\n    .ofType&#x3C;Login>(UserActions.LOGIN)\n    .pipe(\n      map(action => action.payload),\n      map(() => new AnotherAction())\n    );\n\n  constructor(private actions$: Actions) {}\n}\n</code-example>\n<p>If you prefer to keep the <code>payload</code> interface property, you can provide your own parameterized version.</p>\n<code-example language=\"ts\">\nexport interface ActionWithPayload&#x3C;T> extends Action {\n  payload: T;\n}\n</code-example>\n<p>And if you need an unsafe version to help with transition.</p>\n<code-example language=\"ts\">\nexport interface UnsafeAction extends Action {\n  payload?: any;\n}\n</code-example>\n<h3 id=\"registering-reducers\">Registering Reducers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#registering-reducers\"><i class=\"material-icons\">link</i></a></h3>\n<p>Previously to be AOT compatible, it was required to pass a function to the <code>provideStore</code> method to compose the reducers into one root reducer. The <code>initialState</code> was also provided to the method as an object in the second argument.</p>\n<p>BEFORE:</p>\n<p><code>reducers/index.ts</code></p>\n<code-example language=\"ts\">\nconst reducers = {\n  auth: fromAuth.reducer,\n  layout: fromLayout.reducer,\n};\n\nconst rootReducer = combineReducers(reducers);\n\nexport function reducer(state: any, action: any) {\n  return rootReducer(state, action);\n}\n</code-example>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\nimport { StoreModule } from '@ngrx/store';\nimport { reducer } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.provideStore(reducer, {\n      auth: {\n        loggedIn: true,\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n</code-example>\n<p>This has been simplified to only require a map of reducers that will be composed together by the library. A second argument is a configuration object where you provide the <code>initialState</code>.</p>\n<p>AFTER:</p>\n<p><code>reducers/index.ts</code></p>\n<code-example language=\"ts\">\nimport { ActionReducerMap } from '@ngrx/store';\n\nexport interface State {\n  auth: fromAuth.State;\n  layout: fromLayout.State;\n}\n\nexport const reducers: ActionReducerMap&#x3C;State> = {\n  auth: fromAuth.reducer,\n  layout: fromLayout.reducer,\n};\n</code-example>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\nimport { StoreModule } from '@ngrx/store';\nimport { reducers } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers, {\n      initialState: {\n        auth: {\n          loggedIn: true,\n        },\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n</code-example>\n<h2 id=\"ngrxeffects\">@ngrx/effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#ngrxeffects\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"registering-effects\">Registering Effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#registering-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p>BEFORE:</p>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\n@NgModule({\n  imports: [EffectsModule.run(SourceA), EffectsModule.run(SourceB)],\n})\nexport class AppModule {}\n</code-example>\n<p>AFTER:</p>\n<p>The <code>EffectsModule.forRoot</code> method is <em>required</em> in your root <code>AppModule</code>. Provide an empty array\nif you don't need to register any root-level effects.</p>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\n@NgModule({\n  imports: [EffectsModule.forRoot([SourceA, SourceB, SourceC])],\n})\nexport class AppModule {}\n</code-example>\n<p>Import <code>EffectsModule.forFeature</code> in any NgModule, whether be the <code>AppModule</code> or a feature module.</p>\n<p><code>feature.module.ts</code></p>\n<code-example language=\"ts\">\n@NgModule({\n  imports: [\n    EffectsModule.forFeature([FeatureSourceA, FeatureSourceB, FeatureSourceC]),\n  ],\n})\nexport class FeatureModule {}\n</code-example>\n<h3 id=\"init-action\">Init Action<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#init-action\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>@ngrx/store/init</code> action now fires prior to effects starting. Use defer() for the same behaviour.</p>\n<p>BEFORE:</p>\n<p><code>app.effects.ts</code></p>\n<code-example language=\"ts\">\nimport { Dispatcher, Action } from '@ngrx/store';\nimport { Actions, Effect } from '@ngrx/effects';\n\nimport * as auth from '../actions/auth.actions';\n\n@Injectable()\nexport class AppEffects {\n  @Effect()\n  init$: Observable&#x3C;Action> = this.actions$\n    .ofType(Dispatcher.INIT)\n    .switchMap(action => {\n      return of(new auth.LoginAction());\n    });\n\n  constructor(private actions$: Actions) {}\n}\n</code-example>\n<p>AFTER:</p>\n<p><code>app.effects.ts</code></p>\n<code-example language=\"ts\">\nimport { Action } from '@ngrx/store';\nimport { Actions, Effect } from '@ngrx/effects';\nimport { defer } from 'rxjs';\n\nimport * as auth from '../actions/auth.actions';\n\n@Injectable()\nexport class AppEffects {\n  @Effect()\n  init$: Observable&#x3C;Action> = defer(() => {\n    return of(new auth.LoginAction());\n  });\n\n  constructor(private actions$: Actions) {}\n}\n</code-example>\n<h3 id=\"testing-effects\">Testing Effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#testing-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p>BEFORE:</p>\n<code-example language=\"ts\">\nimport { EffectsTestingModule, EffectsRunner } from '@ngrx/effects/testing';\nimport { MyEffects } from './my-effects';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let runner: EffectsRunner;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [EffectsTestingModule],\n      providers: [\n        MyEffects,\n        // other providers\n      ],\n    });\n\n    effects = TestBed.inject(MyEffects);\n    runner = TestBed.inject(EffectsRunner);\n  });\n\n  it('should work', () => {\n    runner.queue(SomeAction);\n\n    effects.someSource$.subscribe(result => {\n      expect(result).toBe(AnotherAction);\n    });\n  });\n});\n</code-example>\n<p>AFTER:</p>\n<code-example language=\"ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { provideMockActions } from '@ngrx/effects/testing';\nimport { hot, cold } from 'jasmine-marbles';\nimport { MyEffects } from './my-effects';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let actions: Observable&#x3C;any>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        MyEffects,\n        provideMockActions(() => actions),\n        // other providers\n      ],\n    });\n\n    effects = TestBed.inject(MyEffects);\n  });\n\n  it('should work', () => {\n    actions = hot('--a-', { a: SomeAction, ... });\n\n    const expected = cold('--b', { b: AnotherAction });\n\n    expect(effects.someSource$).toBeObservable(expected);\n  });\n\n  it('should work also', () => {\n    actions = new ReplaySubject(1);\n\n    actions.next(SomeAction);\n\n    effects.someSource$.subscribe(result => {\n      expect(result).toBe(AnotherAction);\n    });\n  });\n});\n</code-example>\n<h2 id=\"ngrxrouter-store\">@ngrx/router-store<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#ngrxrouter-store\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"registering-the-module\">Registering the module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#registering-the-module\"><i class=\"material-icons\">link</i></a></h3>\n<p>BEFORE:</p>\n<p><code>reducers/index.ts</code></p>\n<code-example language=\"ts\">\nimport * as fromRouter from '@ngrx/router-store';\n\nexport interface State {\n  router: fromRouter.RouterState;\n}\n\nconst reducers = {\n  router: fromRouter.routerReducer,\n};\n\nconst rootReducer = combineReducers(reducers);\n\nexport function reducer(state: any, action: any) {\n  return rootReducer(state, action);\n}\n</code-example>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\nimport { RouterModule } from '@angular/router';\nimport { RouterStoreModule } from '@ngrx/router-store';\nimport { reducer } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.provideStore(reducer),\n    RouterModule.forRoot([\n      // some routes\n    ])\n    RouterStoreModule.connectRouter()\n  ]\n})\nexport class AppModule {}\n</code-example>\n<p>AFTER:</p>\n<p><code>reducers/index.ts</code></p>\n<code-example language=\"ts\">\nimport * as fromRouter from '@ngrx/router-store';\n\nexport interface State {\n  routerReducer: fromRouter.RouterReducerState;\n}\n\nexport const reducers = {\n  routerReducer: fromRouter.routerReducer,\n};\n</code-example>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\nimport { reducers } from './reducers';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot(reducers),\n    RouterModule.forRoot([\n      // some routes\n    ]),\n    StoreRouterConnectingModule,\n  ],\n})\nexport class AppModule {}\n</code-example>\n<h3 id=\"navigation-actions\">Navigation actions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#navigation-actions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Navigation actions are not provided as part of the V4 package. You provide your own\ncustom navigation actions that use the <code>Router</code> within effects to navigate.</p>\n<p>BEFORE:</p>\n<code-example language=\"ts\">\nimport { go, back, forward } from '@ngrx/router-store';\n\nstore.dispatch(\n  go(['/path', { routeParam: 1 }], { page: 1 }, { replaceUrl: false })\n);\n\nstore.dispatch(back());\n\nstore.dispatch(forward());\n</code-example>\n<p>AFTER:</p>\n<code-example language=\"ts\">\nimport { Action } from '@ngrx/store';\nimport { NavigationExtras } from '@angular/router';\n\nexport const GO = '[Router] Go';\nexport const BACK = '[Router] Back';\nexport const FORWARD = '[Router] Forward';\n\nexport class Go implements Action {\n  readonly type = GO;\n\n  constructor(\n    public payload: {\n      path: any[];\n      query?: object;\n      extras?: NavigationExtras;\n    }\n  ) {}\n}\n\nexport class Back implements Action {\n  readonly type = BACK;\n}\n\nexport class Forward implements Action {\n  readonly type = FORWARD;\n}\n\nexport type Actions = Go | Back | Forward;\n</code-example>\n<code-example language=\"ts\">\nimport * as RouterActions from './actions/router';\n\nstore.dispatch(new RouterActions.Go({\n  path: ['/path', { routeParam: 1 }],\n  query: { page: 1 },\n  extras: { replaceUrl: false }\n});\n\nstore.dispatch(new RouterActions.Back());\n\nstore.dispatch(new RouterActions.Forward());\n</code-example>\n<code-example language=\"ts\">\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Location } from '@angular/common';\nimport { Effect, Actions } from '@ngrx/effects';\nimport { map, tap } from 'rxjs/operators';\nimport * as RouterActions from './actions/router';\n\n@Injectable()\nexport class RouterEffects {\n  @Effect({ dispatch: false })\n  navigate$ = this.actions$.ofType(RouterActions.GO).pipe(\n    map((action: RouterActions.Go) => action.payload),\n    tap(({ path, query: queryParams, extras }) =>\n      this.router.navigate(path, { queryParams, ...extras })\n    )\n  );\n\n  @Effect({ dispatch: false })\n  navigateBack$ = this.actions$\n    .ofType(RouterActions.BACK)\n    .do(() => this.location.back());\n\n  @Effect({ dispatch: false })\n  navigateForward$ = this.actions$\n    .ofType(RouterActions.FORWARD)\n    .do(() => this.location.forward());\n\n  constructor(\n    private actions$: Actions,\n    private router: Router,\n    private location: Location\n  ) {}\n}\n</code-example>\n<h2 id=\"ngrxstore-devtools\">@ngrx/store-devtools<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#ngrxstore-devtools\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"instrumentation-method\">Instrumentation method<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration/v4#instrumentation-method\"><i class=\"material-icons\">link</i></a></h3>\n<p><strong>NOTE:</strong> store-devtools currently causes severe performance problems when\nused with router-store. We are working to\n<a href=\"https://github.com/ngrx/platform/issues/97\">fix this</a>, but for now, avoid\nusing them together.</p>\n<p>BEFORE:</p>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\n\n@NgModule({\n  imports: [\n    StoreDevtoolsModule.instrumentStore({ maxAge: 50 }),\n    // OR\n    StoreDevtoolsModule.instrumentOnlyWithExtension({\n      maxAge: 50,\n    }),\n  ],\n})\nexport class AppModule {}\n</code-example>\n<p>AFTER:</p>\n<p><code>app.module.ts</code></p>\n<code-example language=\"ts\">\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../environments/environment'; // Angular CLI environment\n\n@NgModule({\n  imports: [\n    !environment.production\n      ? StoreDevtoolsModule.instrument({ maxAge: 50 })\n      : [],\n  ],\n})\nexport class AppModule {}\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/migration/v4#action-interface\n - guide/migration/v4#dependencies\n - guide/migration/v4#init-action\n - guide/migration/v4#instrumentation-method\n - guide/migration/v4#navigation-actions\n - guide/migration/v4#ngrxcore\n - guide/migration/v4#ngrxeffects\n - guide/migration/v4#ngrxrouter-store\n - guide/migration/v4#ngrxstore\n - guide/migration/v4#ngrxstore-devtools\n - guide/migration/v4#registering-effects\n - guide/migration/v4#registering-reducers\n - guide/migration/v4#registering-the-module\n - guide/migration/v4#testing-effects\n - guide/migration/v4#v4-update-guide\n - https://github.com/ngrx/platform/edit/master/NODEJS/ngrx.io/content/guide/migration/v4.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/ngrx/platform/issues/97\n-->"
}